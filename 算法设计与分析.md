# 算法设计与分析

[TOC]

## 概论

### 图灵机模型

图灵机模型的基本结构包括：一条向右无限延伸的输入带，一个有限状态控制器和连接控制器与输入带的读写头。

### P 类、NPC 类和 NP 类问题

- P 类，用确定的图灵机以多项式时间界可解的问题；
- NP 类，用不确定的图灵机以多项式时间界可解的问题；
- NPC 类，

## 递归

定义一个函数时出现调用本函数的成分，称之为递归。

- 每递归调用一次，就需要进栈一次，最多的进栈元素称为递归深度，当 n 越大，递归深度越深，开辟的栈空间也越大。
- 每当遇到递归完成本次执行时，需退栈一次，并恢复参量值，当全部执行完毕时，栈应为空。

```c++
int Fib(int n){
    if(n==1 || n==2)
        return 1;
    else
        return Fib(n-1)+Fib(n-2);
}
```

### 递归算法转化为非递归算法

- 用循环结构代替递归过程，特别适合尾递归，也适合与单向递归。
- 用栈模拟系统的运行过程，只保存必须保存的信息。

```c++
int Fib(int n){
    int f1=1,f2=1,f3;
    if(n==1 || n==2)
        return 1;
    for(int i=3;i<=n;i++){
        f3=f1+f2;
        f1=f2;
        f2=f3;
    }
    return f3;
}
```

## 穷举法

穷举法的基本思想是对问题的所有可能状态一一测试，直到找到解或将全部可能状态都测试为止。

使用穷举法通常有如下几种情况：

- 搜索所有的解空间
- 搜索所有的路径
- 直接计算
- 模拟和仿真

## 分治法

对于一个规模为 n 的问题，将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解决这些子问题，然后将各个子问题的解合并得到原问题的解。

分治法所能解决的问题一般具有以下几个特征：

- 该问题的规模缩小到一定的程度就可以很容易地解决
- 该问题可以分解为若干个规模较小的相同问题
- 利用该问题分解出的子问题的解可以合并为该问题的解
- 该问题所分解出的各个子问题是互相独立的

比如经典的快速排序、归并排序、折半查找算法。

## 贪心法

贪心算法是指在对问题求解时，总是做出当前看来时最好的选择。也就是说贪心法不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。

能够采用贪心法求解的问题一般具有两个性质：

- 贪心选择性质

  所求问题的整体最优解可以通过一系列局部最优的选择。

- 最优子结构性质

  一个问题的最优解包含其子问题的最优解

比如迪杰斯特拉（Dijkstra）算法。

## 动态规划

动态规划是将多阶段决策问题进行公式化的一种技术，动态规划中的几个基本概念

1. 阶段和阶段变量

   每个阶段用阶段变量 k 标识。

2. 状态和状态变量

   描述决策过程当前特征的量称为状态，可以是数量，也可以是字符，状态变量记为 $s_k$。

3. 决策和决策变量

   决策就是决策者在过程处于某一阶段的某一状态时，面对下一阶段的状态做出的选择或决定，决策变量记为 $x_k$。

4. 策略

   策略就是策略者从第一阶段到最后阶段全过程的决策构成的决策序列。

5. 状态转移方程

   某一状态以及该状态下的决策，与下一状态之间的函数关系称为状态转移方程。

6. 指标函数和最优指标函数

   指标函数是衡量对决策过程进行控制的效果的数量指标。最优过程对应的指标函数称为最优指标函数。

能采用动态规划求解的问题一般具有 3 个性质：

- 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，满足最优化原理。
- 无后效性：某状态一旦确定，就不受这个状态以后决策的影响。
- 有重叠子问题：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。

一般要经历一下几个步骤：

1. 划分阶段
2. 确定状态和状态变量
3. 确定决策并写出状态转移方程
4. 寻找边界条件

## 回溯法

问题的解空间一般用树形式来组织，也称为解空间或状态空间，树中的每一个结点是所求解问题的一个问题状态。

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发搜索解空间树。在当前的结点处，搜索向纵向方向移至一个新结点。如果当前的结点不能再向纵深方向移动，则成为死结点。此时应往回移动至最近的一个结点处。回溯法以这种方式递归地在解空间中搜索，直至找到所要求的解或无解。

用回溯法解题的一般步骤如下：

- 针对所给问题，确定问题的解空间树，问题的解空间树应至少包含问题的一个（最优）解。
- 确定结点的扩展搜索规则。
- 以深度优先方式搜索解空间树，并在搜索过程中可以采用剪枝函数来避免无效搜索。

在通常情况下，解空间树为子集树时对应算法的时间复杂度为$O(2^n)$，解空间树为排列树时对应算法的时间复杂度为$O(n!)$。