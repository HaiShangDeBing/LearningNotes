
[TOC]

## 概述

### 直接内存存取

执行 IO 操作的技术有三种：可编程 IO、中断驱动 IO 和 直接内存存取（DMA）。

### 多道程序设计

假设内存空间容得下操作系统和两个用户程序，那么当一个作业需要等待 IO 时，处理器可以切换到另一个可能并不在等待 IO 的作业。

### 进程

关于进程的定义，如下所示：

- 一个正在执行的程序
- 计算机中正在运行的程序的一个实例
- 可分配给处理器并由处理器执行的一个实体
- 由一个单一顺序线程、一个当前状态和一组相关的系统资源所表征的活动单元。

进程由三部分组成：

- 一段可执行的程序
- 程序所需要的相关数据（变量、工作区间、缓冲区间）
- 程序的执行上下文（execution context）

执行上下文又称为进程状态，是操作系统用来管理和控制进程所需的内部数据。

产生错误的主要原因：

- 不正确的同步
- 失败的互斥
- 不确定的程序操作
- 死锁

### 内存管理

操作系统担负着 5 项存储器管理职责：

- 进程隔离
- 自动分配和管理
- 支持模块化程序设计
- 保护和访问控制
- 长期存储

在分页系统中，进程由许多固定大小的块组成，这些块称为页。程序通过虚地址访问字，虚地址由页号和页中的偏移量组成。

### 信息保护和安全

与操作系统相关的大多数安全和保护问题可分为 4 类：

- 可用性
- 保密性
- 数据完整性
- 认证

### 调度和资源管理

任何资源分配和调度策略都须考虑 3 个因素：

- 公平性
- 有差别的响应性
- 有效性


UNIX 是 C 语言编写的

## 进程

进程的两个基本元素是程序代码和与代码相关联的数据集。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

PCB 包括**标识符，状态，优先级，程序计数器，内存指针，IO状态信息**等。

### 进程5状态模型

- 创建态
- 就绪态
- 运行态
- 阻塞态
- 终止态


![](image/ProcessState.png)

## 线程

一个进程中可能有一个或多个线程，每个线程都有：

- 一个线程执行状态
- 未运行时保存的线程上下文；线程可视为在进程内运行的一个独立程序计数器
- 一个执行栈
- 每个线程用于局部变量的一些静态存储空间
- 与进程内其他线程共享的内存和资源的访问

比较性能后会发现线程有如下优点：

- 创建新线程的时间远少于创建一个全新进程的时间。
- 终止线程要比终止进程所花的时间横扫
- 同一进程内线程间切换的时间要少于进程间切换的时间
- 线程提高了不同执行程序间通信的效率。独立进程间的通信需要内核介入，而同一进程中的多个线程共享内存和文件，因此无需调用内核就可互相通信。

线程分为两大类，即用户级线程（ULT）和内核机线程（KLT），后者又称内核支持的线程或轻量级进程。

在纯ULT软件中，管理线程的所有工作都由应用程序完成，内核意识不到线程的存在。在纯KLT软件中，管理线程的所有工作均由内核完成，应用级没有线程管理代码，只有一个到内核线程设施的应用编程借口，Windows是这种方法的一个例子。

ULT线程切换不需要内核模式特权，不会乱底层的操作系统调度程序，可在任何操作系统中运行，不需要对底层内核进程修改以支持ULT。

在ULT执行一个系统调用时，不仅会阻塞这个线程，也会阻塞进程中的所有线程；在纯ULT策略中，多线程应用程序不能利用多核处理技术。

## 并发性：互斥和同步

- 原子操作

  一个函数或动作由一个或多个指令的序列实现，对外是不可见的；也就是说，没有其他进程可以看到其中间状态或能中断此操作。原子性保证了并发进程的隔离。

- 临界区

  一段代码，在这段代码中进程将访问共享资源，当另外一个进程已在这段代码中运行时，这个进程就不能在这段代码中执行。

- 死锁

  两个或两个以上的进程因每个进程都在等待其他进程做完某些事情而不能继续执行的情况

- 活锁

  两个或两个以上的进程为响应其他进程中的变化而持续改变子集的状态但不做有用的工作的情况

- 互斥

  当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源的情况

- 竞争条件

  多个线程或进程在读写一个共享数据时，结果依赖于它们执行的相对时间的情况

- 饥饿

  一个可运行的进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情况

### 互斥的要求

- 必须强制实施互斥，在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区。
- 一个在非临界区停止的进程不能干涉其他进程
- 绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会死锁或饥饿
- 一个进程驻留在临界区的时间必须是有限的

实现互斥的硬件方法：

- 中断禁用

  代价高，有时并不能保证互斥

- 专用机器指令

  一些机器指令，用于保证两个动作的原子性，如在一个取指周期中对一个存储器单元的读和写或读和测试。在这个指令执行的过程中，任何其他指令访问内存都将被阻止，而且这些动作在一个指令周期中完成。

### 信号量

用于进程间传递信号的一个整数值。在信号量上只可进行三种操作，即初始化、递减和递增。二元信号量是只取0值和1值的信号量。

设有n个进程，用数组P(i)表示，所有进程都需要访问共享资源。每个进程进入临界区前执行semWait(s)，若s的值为负，则进程被阻塞；若值为1，则s被减为0，进程立即进入临界区；由于s不再为正，因而其他任何进程都不能进入临界区。

### 管程

管程是由一个或多个进程、一个初始化序列和局部数据组成的软件模块，其主要特点如下:

- 局部数据变量只能被管程的过程访问，任何外部过程都不能访问
- 一个进程通过调用管程的一个过程进入管程
- 在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都会被阻塞，以等待管程可用

管程通过使用条件变量来支持同步，这些条件变量包含在管程中，并且只有在管程中才能被访问。

### 消息传递

进程交互时，必须满足两个基本要求：同步和通信。为了实施互斥，进程间需要同步；为实现合作，进程间需要交换信息。提供这些功能的一种方法就是消息传递。

## 并发：死锁和饥饿

死锁有三个必要条件：

- 互斥。一次只有一个进程可以使用一个资源，其他进程不能访问已分配给其他进程的资源。
- 占有且等待。当一个进程等待其他进程时，继续占有已分配的资源。
- 不可抢占。不能强行抢占进程已占有的资源。

例如，要确保结果的一致性和数据库的完整性，互斥时非常有必要的。同理，不能随意地进行资源抢占。比如，在涉及数据资源时，必须提供回滚恢复机制来支持资源抢占，只有这样才能把进程及其资源恢复到以前的适当状态，使得进程最终可以重复其动作。

要产生死锁，还需要第四个条件：

- 循环等待。存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源。

处理死锁的方法有三种：

- 死锁预防。采用某种策略消除四个条件的某个条件的出现，来预防死锁。
- 死锁避免。基于资源分配的当前状态做动态选择来避免死锁。
- 死锁检测。试图检测死锁的存在并从死锁中恢复。

### 死锁预防

死锁预防方法分为两类：

- 间接死锁预防方法，即防止前三个必要条件中的任意一个条件的发生。
- 直接死锁预防，即防止循环等待的发生。

对于互斥，不可能禁止。不过某些资源，如文件，可能允许多个读访问，但只能允许互斥的写访问，此时若有多个进程请求写权限，则也可能发生死锁。

为预防占有且等待条件，可以要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足。

预防不可抢占的方法有几种。首先，占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放其最初占有的资源，必要时可再次申请这些资源和其他资源。其次，一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源。

循环等待条件可通过定义资源类型的线性顺序来预防。若一个进程已分配了R类型的资源，则其接下来请求的资源只能是那些排在R类型之后的资源。

### 死锁避免

两种死锁避免方法：

- 若一个进程的请求会导致死锁，则不会启动该进程
- 若一个进程增加的资源请求会导致死锁，则不允许这一资源分配

资源分配拒绝测策略，又称为银行家算法。类似于银行业务。重银行贷款的顾客对应于进程，贷出的钱对应于资源。作为银行业务问题，银行能贷出的钱有限，每名顾客都有一定的银行信用额。顾客可以选择借一部分，但不能保证顾客取得大量贷款后一定能偿还。银行没有足够的本金放贷时，银行也会拒绝贷款给顾客。

死锁避免的优点是，无须死锁预防中的抢占和回滚进程，且与死锁预防相比限制减少。但是，它在使用中也有许多限制：

- 必须事先申明每个进程请求的最大资源
- 所讨论的进程必须是无关的，即它们的执行顺序必须没有任何同步要求的限制。
- 分配的资源数量必须是固定的。
- 在占有资源时，进程不能退出。

### 死锁检测

